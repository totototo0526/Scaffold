# アプリケーション画面生成ロジック仕様書

## 1. 概要

このアプリケーションは、データベースの定義情報を元にUIを動的に生成する**データ駆動型アーキテクチャ**を採用している。
画面の「外側（ナビゲーションや文脈）」は`m_content`テーブル、「内側（UI部品）」は`m_hanyo`テーブルによって主に制御される。画面固有のデータ操作やビジネスロジックは、PostgreSQL関数が担う。
このアーキテクチャにより、UIの9割はデータベースへのレコード登録で実装でき、開発者は画面固有のロジック（関数）の実装に集中できる。

---

## 2. 主要テーブルの役割

### 2.1. `m_content`テーブル

ページの**周辺情報（コンテキスト）**を定義する。

-   **ナビゲーション**: ヘッダーメニューやサイドバーに表示されるリンクを定義する。`parent_id`で階層構造を管理する。
-   **ページ情報**: パンくずリストやブラウザタブに表示されるページタイトルを提供する。
-   **仮想親 (`dummy`)**: メニューには表示しないが、システム上は必要なページ（新規作成画面、詳細画面など）を管理するための仮想的な親として機能する。
-   **補足**: このテーブルに定義がなくても、URLと`m_hanyo`の定義が合致すればページの主要コンテンツは表示される。

### 2.2. `m_hanyo`テーブル

UI部品の**設計図**そのものを定義する、画面生成の心臓部。
`mst_kbn`（マスタ区分）によって、レコードが持つ役割が変化する。

---

## 3. UI定義の仕組み (`m_hanyo`詳細)

`m_hanyo`は`mst_kbn`を使い分けることで、UIの部品を定義する。

| `mst_kbn` | UI部品 | 役割 |
| :--- | :--- | :--- |
| **`CB`** | **コントローラー** | URLの識別子 (`han_name`) と、UI定義をまとめる**グループID** (`koumoku1`) を紐づける司令塔。 |
| **`CC`** | **ページレイアウト** | ページ内に「ヘッダ (`head`)」「明細 (`detail`)」といった領域を作り、そこにどのUI部品グループ (`koumoku5`) を配置するかを指示する監督役。 |
| **`C1`** | **編集フォーム** | 新規作成・編集画面で使われる、**入力可能なフォーム**を定義する。 |
| **`C2`** | **検索フォーム** | 検索モーダルや、`C1`フォーム内の**検索ポップアップ（ルックアップ）**の入力欄を定義する。詳細ページの静的表示(`head`)の際にも必要とされる。 |
| **`C3`** | **一覧グリッド** | 検索結果や、詳細画面の明細行を表示する**リスト**を定義する。`koumoku10`にキーとなる**フィールド名**を指定すると詳細画面へのリンクになる。 |
| **`CD`** | **アクション** | 「新規作成」「編集」「更新」といった**ボタン**とその動作を定義する。 |
| `01`, `05`等 | **選択肢マスタ** | `C1`/`C2`で定義された`select`（ドロップダウン）の選択肢を提供する。 |

---

## 4. 動的処理の仕組み（関数）

画面固有のビジネスロジックやデータ操作は、PostgreSQL関数によって実現される。これらの関数は明確な階層構造を持っている。

### 4.1. 階層化された関数呼び出し

1.  **第1層: アクションの司令塔 (`fnc_query_action_*`)**
    -   ユーザーの操作（例：「編集ボタンをクリック」）をJSON内の`action`キーで受け取る。
    -   `action`の値に応じて、画面表示の準備を行うための下位関数を呼び出す。
    -   例：`action: 'edit'`なら、`fnc_query_begin_update_*`を呼び出して編集画面のデータを準備する。

2.  **第2層: データ保存の実行役 (`fnc_query_commit_edit_*`)**
    -   「更新」「登録」ボタンが押された際に呼ばれる。
    -   受け取ったデータが新規か既存かを判断し、`INSERT`用または`UPDATE`用の最終書き込み関数を呼び分ける。

3.  **第3層: 汎用的なSQL実行エンジン (`fnc_*_mainte_one`)**
    -   `m_hanyo`の`C1`定義を元に、**`INSERT`や`UPDATE`のSQL文を動的に組み立てて実行する**汎用関数。
    -   このエンジンの存在により、新しい画面を追加する際に個別の`INSERT`/`UPDATE`文を書く必要がなくなる。

---

## 5. 画面生成・操作の全体フロー

### 5.1. 詳細画面の表示フロー

1.  **リンククリック**: 一覧画面(`C3`定義)で、`koumoku10`にキー項目（例: `hin_cd`）が指定されたリンクをクリックする。
2.  **URL解決**: URL (`.../msyohin/39`) がサーバーに送信される。
3.  **UI定義特定**:
    -   `m_hanyo`の`CB`がURLの`msyohin`をキーに、UIグループID（例: `msyohin`）を特定する。
    -   `m_hanyo`の`CC`が、そのグループIDを元にページレイアウト（`head`領域など）を決定する。
    -   `head`領域に紐づけられた部品グループID（例: `msyohin`）を元に、必要な`C1`/`C2`の設計図が読み込まれる。
4.  **データ取得**: 詳細データ取得用の関数（例: `fnc_get_msyohin(39)`）が呼ばれる。
5.  **描画**: `CC`のレイアウト指示に基づき、`C1`/`C2`の設計図が**静的な表示モード**で描画され、取得したデータが埋め込まれる。

### 5.2. データ更新フロー

1.  **編集モードへの切り替え**:
    -   詳細画面で「編集」ボタン(`CD`定義)をクリックする。
    -   **アクション司令塔 (`fnc_query_action_*`)**が`action: 'edit'`を受け取り、編集画面の準備をする。
    -   画面が**編集モード**に切り替わり、`C1`定義が**入力可能なフォーム**として再描画される。
2.  **データ更新**:
    -   ユーザーがデータを変更し「更新」ボタン(`CD`定義)をクリックする。
    -   フォームの内容がJSON化され、**データ保存の実行役 (`fnc_query_commit_edit_*`)**が呼び出される。
3.  **DB保存**:
    -   実行役関数は、データが既存であると判断し、**汎用SQL実行エンジン (`fnc_update_mainte_one`)**を呼び出す。
    -   エンジンは`m_hanyo`の`C1`定義を元に`UPDATE`文を動的に生成し、データベースを更新する。